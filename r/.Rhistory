}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
betas
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
X
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
names(betas) <- colnames(X)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
# Discard burn-in
burn_in <- 2000
posterior_samples <- mcmc_chain[(burn_in + 1):nrow(mcmc_chain), ]
# Assign column names for clarity
colnames(posterior_samples) <- colnames(X)
# Check posterior means for each parameter
colMeans(posterior_samples)
loan_data <- read.csv("../loan_data.csv", stringsAsFactors = FALSE)
# preprocess columns needed
numeric_cols <- c("credit_score", "person_income", "loan_amnt", "loan_percent_income")
loan_data[ , numeric_cols] <- scale(loan_data[ , numeric_cols])
y <- loan_data$loan_status
# intercept, credit_score, person_income, loan_amnt
X <- model.matrix(~ credit_score + loan_intent + loan_percent_income + previous_loan_defaults_on_file,
data = loan_data)
colnames(X)[colnames(X) == "previous_loan_defaults_on_fileYes"] <- "defaults"
dim(X)
length(y)
head(X)
loan_data <- read.csv("../loan_data.csv", stringsAsFactors = FALSE)
# preprocess columns needed
numeric_cols <- c("credit_score", "person_income", "loan_amnt", "loan_percent_income")
loan_data[ , numeric_cols] <- scale(loan_data[ , numeric_cols])
y <- loan_data$loan_status
# intercept, credit_score, person_income, loan_amnt
X <- model.matrix(~ credit_score + loan_intent + loan_percent_income + previous_loan_defaults_on_file,
data = loan_data)
colnames(X)[colnames(X) == "previous_loan_defaults_on_fileYes"] <- "defaults"
colnames(X)[colnames(X) == "loan_intentEDUCATION"] <- "intentEDUCATION"
colnames(X)[colnames(X) == "loan_intentHOMEIMPROVEMENT"] <- "intentHOMEIMPROVEMENT"
colnames(X)[colnames(X) == "loan_intentMEDICAL"] <- "intentMEDICAL"
colnames(X)[colnames(X) == "loan_intentPERSONAL"] <- "intentPERSONAL"
colnames(X)[colnames(X) == "loan_intentVENTURE"] <- "intentVENTURE"
dim(X)
length(y)
head(X)
logistic <- function(z) {
1 / (1 + exp(-z))
}
log_prior <- function(betas, prior_sd=5) {
# Sum of logs of independent Normal(0, prior_sd^2)
sum(dnorm(betas, mean=0, sd=prior_sd, log=TRUE))
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9
ll <- sum(y*log(p + eps) + (1 - y)*log(1 - p + eps))
return(ll)
}
log_posterior <- function(betas, X, y, prior_sd=5) {
log_lik(betas, X, y) + log_prior(betas, prior_sd)
}
run_mcmc <- function(X, y, n_iter=10000, prior_sd=5, prop_sd=0.01) {
# X: design matrix
# y: response vector (0/1)
# n_iter: number of MCMC iterations
# prior_sd: prior std dev for betas
# prop_sd: proposal std dev for random walk
p <- ncol(X)
betas <- rep(0, p)
chain <- matrix(NA, nrow=n_iter, ncol=p)
colnames(chain) <- paste0("beta_", 0:(p-1))
# Compute initial log posterior
curr_lp <- log_posterior(betas, X, y, prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean=0, sd=prop_sd)
# Compute log posterior for proposed betas
new_lp <- log_posterior(betas_star, X, y, prior_sd)
# Metropolis acceptance ratio
r <- exp(new_lp - curr_lp)
# Accept or reject
if (runif(1) < r) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
return(chain)
}
mcmc_chain <- run_mcmc(X, y, n_iter=10000, prior_sd=5, prop_sd=0.01)
# Discard burn-in
burn_in <- 2000
posterior_samples <- mcmc_chain[(burn_in+1):nrow(mcmc_chain), ]
# Check posterior means for each parameter
colnames(posterior_samples) <- colnames(X)
colMeans(posterior_samples)
beta_means <- colMeans(posterior_samples)
beta_median <- apply(posterior_samples, 2, median)
beta_CI <- apply(posterior_samples, 2, quantile, probs=c(0.025,0.975))
beta_means
beta_median
beta_CI
if(!require(coda)) install.packages("coda", repos='http://cran.us.r-project.org')
library(coda)
mcmc_obj <- as.mcmc(posterior_samples)
param_names <- colnames(mcmc_obj)
n_params <- length(param_names)
# Set up a layout: for example, 2 columns and enough rows
par(mfrow = c(ceiling(n_params/2), 2))
for(i in seq_along(param_names)) {
plot(mcmc_obj[, i], type = "l",
main = paste("Traceplot for", param_names[i]),
xlab = "Iteration", ylab = "Value")
}
# Determine number of parameters
num_params <- ncol(mcmc_obj)
# Set up grid
ncol_grid <- 3
nrow_grid <- ceiling(num_params / ncol_grid)
par(mfrow = c(nrow_grid, ncol_grid))
# Plot each ACF
for (param in colnames(mcmc_obj)) {
acf(mcmc_obj[, param],
main = paste("ACF for", param),
lag.max = 50)
}
# Reset layout if needed
par(mfrow = c(1, 1))
library(ROCR)
logistic <- function(z) {
1 / (1 + exp(-z))
}
pred_matrix <- logistic(X %*% t(posterior_samples))
pred_probs <- rowMeans(pred_matrix)
head(pred_probs)
pred_obj <- prediction(pred_probs, y)
perf <- performance(pred_obj, measure = "tpr", x.measure = "fpr")
plot(perf, col = "blue", main = "ROC Curve")
abline(a=0, b=1, lty=2, col="gray")  # Reference line
# Calculate AUC
auc <- performance(pred_obj, measure = "auc")
auc_value <- auc@y.values[[1]]
print(paste("AUC:", round(auc_value, 3)))
threshold <- 0.5
pred_class <- ifelse(pred_probs > threshold, 1, 0)
# Confusion Matrix
confusion_matrix <- table(Predicted = pred_class, Actual = y)
print(confusion_matrix)
observed_default_rate <- mean(y)
predicted_default_rate <- mean(pred_probs)
cat("Observed default rate:", round(observed_default_rate, 3), "\n")
cat("Predicted default rate:", round(predicted_default_rate, 3), "\n")
X <- model.matrix(~ credit_score + loan_intent + loan_percent_income,
data = loan_data)
colnames(X)[colnames(X) == "previous_loan_defaults_on_fileYes"] <- "defaults"
colnames(X)[colnames(X) == "loan_intentEDUCATION"] <- "intentEDUCATION"
colnames(X)[colnames(X) == "loan_intentHOMEIMPROVEMENT"] <- "intentHOMEIMPROVEMENT"
colnames(X)[colnames(X) == "loan_intentMEDICAL"] <- "intentMEDICAL"
colnames(X)[colnames(X) == "loan_intentPERSONAL"] <- "intentPERSONAL"
colnames(X)[colnames(X) == "loan_intentVENTURE"] <- "intentVENTURE"
dim(X)
length(y)
head(X)
X <- model.matrix(~ credit_score + loan_intent + loan_percent_income,
data = loan_data)
colnames(X)[colnames(X) == "previous_loan_defaults_on_fileYes"] <- "defaults"
colnames(X)[colnames(X) == "loan_intentEDUCATION"] <- "intentEDUCATION"
colnames(X)[colnames(X) == "loan_intentHOMEIMPROVEMENT"] <- "intentHOMEIMPROVEMENT"
colnames(X)[colnames(X) == "loan_intentMEDICAL"] <- "intentMEDICAL"
colnames(X)[colnames(X) == "loan_intentPERSONAL"] <- "intentPERSONAL"
colnames(X)[colnames(X) == "loan_intentVENTURE"] <- "intentVENTURE"
dim(X)
length(y)
head(X)
log_prior <- function(betas, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
# Ensure betas is a named vector
if(!"loan_percent_income" %in% names(betas)) {
stop("The loan_percent_income coefficient is not found in betas.")
}
# Strong prior for loan_percent_income
lp_income <- dnorm(betas["loan_percent_income"], mean = income_prior_mean, sd = income_prior_sd, log = TRUE)
# Weak priors for the other coefficients (including the intercept and other predictors)
other_names <- names(betas)[names(betas) != "loan_percent_income"]
lp_others <- sum(dnorm(betas[other_names], mean = 0, sd = other_prior_sd, log = TRUE))
lp_income + lp_others
}
log_lik <- function(betas, X, y) {
z <- X %*% betas  # linear predictor
p <- logistic(z)
eps <- 1e-9  # small constant to prevent log(0)
sum(y * log(p + eps) + (1 - y) * log(1 - p + eps))
}
log_posterior <- function(betas, X, y, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5) {
log_lik(betas, X, y) + log_prior(betas, income_prior_mean, income_prior_sd, other_prior_sd)
}
run_mcmc <- function(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01) {
p <- ncol(X)
betas <- rep(0, p)
names(betas) <- colnames(X)
chain <- matrix(NA, nrow = n_iter, ncol = p)
colnames(chain) <- colnames(X)
curr_lp <- log_posterior(betas, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
for (i in seq_len(n_iter)) {
betas_star <- betas + rnorm(p, mean = 0, sd = prop_sd)
new_lp <- log_posterior(betas_star, X, y, income_prior_mean, income_prior_sd, other_prior_sd)
r_ratio <- exp(new_lp - curr_lp)
if (runif(1) < r_ratio) {
betas <- betas_star
curr_lp <- new_lp
}
chain[i, ] <- betas
}
chain
}
# Run the MCMC sampler
mcmc_chain <- run_mcmc(X, y, n_iter = 10000, income_prior_mean = 2, income_prior_sd = 1, other_prior_sd = 5, prop_sd = 0.01)
# Discard burn-in
burn_in <- 2000
posterior_samples <- mcmc_chain[(burn_in + 1):nrow(mcmc_chain), ]
# Assign column names for clarity
colnames(posterior_samples) <- colnames(X)
# Check posterior means for each parameter
colMeans(posterior_samples)
mcmc_obj <- as.mcmc(posterior_samples)
param_names <- colnames(mcmc_obj)
n_params <- length(param_names)
# Set up a layout: for example, 2 columns and enough rows
par(mfrow = c(ceiling(n_params/2), 2))
for(i in seq_along(param_names)) {
plot(mcmc_obj[, i], type = "l",
main = paste("Traceplot for", param_names[i]),
xlab = "Iteration", ylab = "Value")
}
# Determine number of parameters
num_params <- ncol(mcmc_obj)
# Set up grid
ncol_grid <- 3
nrow_grid <- ceiling(num_params / ncol_grid)
par(mfrow = c(nrow_grid, ncol_grid))
# Plot each ACF
for (param in colnames(mcmc_obj)) {
acf(mcmc_obj[, param],
main = paste("ACF for", param),
lag.max = 50)
}
# Reset layout if needed
par(mfrow = c(1, 1))
logistic <- function(z) {
1 / (1 + exp(-z))
}
pred_matrix <- logistic(X %*% t(posterior_samples))
pred_probs <- rowMeans(pred_matrix)
head(pred_probs)
pred_obj <- prediction(pred_probs, y)
perf <- performance(pred_obj, measure = "tpr", x.measure = "fpr")
plot(perf, col = "blue", main = "ROC Curve")
abline(a=0, b=1, lty=2, col="gray")  # Reference line
# Calculate AUC
auc <- performance(pred_obj, measure = "auc")
auc_value <- auc@y.values[[1]]
print(paste("AUC:", round(auc_value, 3)))
threshold <- 0.5
pred_class <- ifelse(pred_probs > threshold, 1, 0)
# Confusion Matrix
confusion_matrix <- table(Predicted = pred_class, Actual = y)
print(confusion_matrix)
observed_default_rate <- mean(y)
predicted_default_rate <- mean(pred_probs)
cat("Observed default rate:", round(observed_default_rate, 3), "\n")
cat("Predicted default rate:", round(predicted_default_rate, 3), "\n")
observed_default_rate <- mean(y)
predicted_default_rate <- mean(pred_probs)
cat("Observed default rate:", round(observed_default_rate, 5), "\n")
cat("Predicted default rate:", round(predicted_default_rate, 5), "\n")
observed_default_rate <- mean(y)
predicted_default_rate <- mean(pred_probs)
cat("Observed default rate:", round(observed_default_rate, 3), "\n")
cat("Predicted default rate:", round(predicted_default_rate, 3), "\n")
